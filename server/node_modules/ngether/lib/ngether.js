/*
	tests in REPL:	
	
	// --- TEST telling named meshNodes
	ngether.tell('desktops/sync/bla', { a:1, b:2 }, [ 'ngetherSpot02_9992_1222' ]);
	ngether.tell('desktops/sync/bla', { a:1, b:2 }, [ 'ngetherSpot02_9992_1222', 'ngetherSpotF01_9993_1223' ] );
	
	// --- TEST broadcasting
	ngether.broadcast('/request/latency/', { a:1, b:2 } );
	
	// --- TEST emitting
	ngether.emit('desktops/sync/emit', { a:1, b:2 } ); 
	
	// --- TEST broadcasting filtering by poolIds
	ngether.broadcast('desktops/sync/broadcasting', { a:1, b:2 }, [ 'webserver' ] );
	ngether.broadcast('desktops/sync/broadcasting', { a:1, b:2 }, [ 'spots' ] );
	
	// --- TEST emitting filtering by poolIds
	ngether.emit('desktops/sync/broadcasting', { a:1, b:2 }, [ 'webserver' ] );
	ngether.emit('desktops/sync/broadcasting', { a:1, b:2 }, [ 'bla' ] );
	ngether.emit('desktops/sync/broadcasting', { a:1, b:2 }, [ 'spots' ] );
	
	// --- TEST broadcast filtering by poolIds with a limit
	ngether.broadcast('desktops/sync/broadcasting', { a:1, b:2 }, [ 'webserver' ], 1 );
	ngether.broadcast('desktops/sync/broadcasting', { a:1, b:2 }, [ 'bla' ], 2 );
	
	// --- TEST emitting filtering by poolIds with a limit
	ngether.emit('desktops/sync/broadcasting', { a:1, b:2 }, [ 'webserver' ], 1 );
	ngether.emit('desktops/sync/broadcasting', { a:1, b:2 }, [ 'bla' ], 2 );
	
	
	// --- TEST eventBridges
	ngether.eventBridge(process, 'test', 'broadcast', process, process);
	process.on('test', function() { console.log('@@@@@@@@@@@@@@EVENT TEST @@@@@@@@@@@@@@@@@@@@@@'); console.log(arguments); } );
	process.emit('test', 1, 'b', 3, { d: 'a' });
	
	
*/


var fs = require('fs');
var http = require('http');
var _logger = require('lg');
var _escalator = require('escalator');
var _bubPubSub = require('bubpubsub');
var _mongodb = require('mongodb');
// https://github.com/Worlize/WebSocket-Node
// https://github.com/Worlize/WebSocket-Node/wiki/Documentation
var WebSocketServer = require('websocket').server;
var WebSocketClient = require('websocket').client;
var WebSocketFrame  = require('websocket').frame;
var WebSocketRouter = require('websocket').router;


var Minions = require('minions');
minions = new Minions(['node']);

// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
// --------------- basic ngether object stuff for instantiation
// ---------------------------------------------------------------------
// ---------------------------------------------------------------------

var ngether = function(config, callback) {
	var thisNgether = this;
	this.config = this.defaultConfig();
	minions.extendShallow(false, this.config, [config]);
	this.id = this.config.id;
	this.connections = {};
	this.attemptingConnectionsTo = [];
	this.subscriptions = {};
	this.commandHandlers = {};
	this.plugins = [];
	this.init(
		function() {
			if (typeof callback === 'function') callback(thisNgether);
		}
	);
	return true;
};


ngether.prototype.releaseData = function() {
	var thisNgether = this;
	var releaseData = {
		authors: [ 'Toni Wagner' ],
		compatibilityCheck: function(remoteNG) {
			var minimumCompatibleVersion = minions.defaultTo(thisNgether.config.minimumCompatibleVersion, '0.6.1');
			var comparison = getHigherSemanticVersion(minimumCompatibleVersion, remoteNG.ngetherVersion);
			return (
				// if both are the same, then comparison will be false
				comparison === false
				// comparison will be set to the higher version...
				|| comparison === remoteNG.ngetherVersion 
			); 
		},
		date: 'June 17, 2013',
		version: '0.6.3',
		license: 'MIT',
		contact: 'i@itsatony.com'
	};
	return releaseData;
};


ngether.prototype.defaultConfig = function() {
	var defaults = {
		id: 'ngetherSpot_' + minions.randomString(12),
		initiallyConnectTo: [],
		poolIds: [],
		allowDirectNetworking: true,
		listConnections: false,
		webSocketClientConfig: {
			maxReceivedMessageSize: 1073741824,  // 1gb
			maxReceivedFrameSize: 1048576, // 1mb
			fragmentOutgoingMessages: true,
			fragmentationThreshold: 16348,
			assembleFragments: true,
			closeTimeout: 5000
		},
		webSocketServerConfig: {
			maxReceivedMessageSize: 1073741824,  // 1gb
			maxReceivedFrameSize: 1048576, // 1mb
			fragmentOutgoingMessages: true,
			fragmentationThreshold: 16348,
			assembleFragments: true,
			keepalive: true,
			dropConnectionOnKeepaliveTimeout: true,
			keepaliveGracePeriod: 10000,
			autoAcceptConnections: false,
			closeTimeout: 5000,
			disableNagleAlgorithm: true
		}
	};
	return defaults;
};


ngether.prototype.runInitialConnects = function() {
	var thisNgether = this;
	var connectingTo = [];
	for (var n in thisNgether.config.initiallyConnectTo) {
		var nextPartner = thisNgether.config.initiallyConnectTo[n];
		if (thisNgether.isConnectedTo(thisNgether.config.initiallyConnectTo[n].id) === false) {
			thisNgether.connectTo(nextPartner);
			connectingTo.push(nextPartner.id);
		}
	}
	return connectingTo;
};


ngether.prototype.loadPlugin = function(pluginName) {
	var thisNgether = this;
	var defaultPath = __dirname + '/plugins/';			
	var lastSlash = pluginName.lastIndexOf('/');
	var pureModuleName = (lastSlash === -1) ? pluginName.substr(lastSlash+1) : pluginName;
	pureModuleName = pureModuleName.substr(0, pureModuleName.lastIndexOf('.') -1 );
	var uri = (lastSlash === -1) ? defaultPath + pluginName : pluginName;
	console.log('[PLUGINS] loading ' + uri);
	thisNgether.plugins[pureModuleName] = require(uri);
	return thisNgether.plugins[pureModuleName];
};


ngether.prototype.init = function(afterInit) {
	var thisNgether = this;
	var init = new _escalator('ngetherInit', [], true);
	var initSteps = [];
	var step_errorHandler = {
		id: 'errorHandler',
		executor: function(next, thisEscalator) {
			process.on('uncaughtException', minions.exceptionHandler);
			exceptionHandler = minions.exceptionHandler;
			next();
		}
	};
	init.add(step_errorHandler);
	var step_logger = {
		id: 'logger',
		executor: function(next, thisEscalator) {
			thisNgether.log = new _logger(thisNgether.config.loggingConfig, next);
		}
	};
	init.add(step_logger);
	var step_pid = {
		id: 'pid',
		delay: 5,
		executor: function(next, thisEscalator) {
			if (typeof thisNgether.config.pidfile !== 'string') {
				next();
				return;
			}
			var filename = __dirname + '/ngether_' + thisNgether.config.id + '.pid';
			fs.writeFile(
				filename,
				'' + process.pid,
				function(err) {
					if (err) {
						throw err;
					}
				}
			);
			process.on(
				'exit',
				function () {
					thisNgether.log.add('removed pidfile.', 'job', 'init');
					fs.unlink(filename);
				}
			);
			thisNgether.log.add('pid: ' + process.pid, 'job', 'init');
			next();
		}
	};
	init.add(step_pid);
	var step_processTitle = {
		id: 'ptitle',
		delay: 5,
		executor: function(next, thisEscalator) {
			process.title = 'ngether_' + thisNgether.config.id;
			thisNgether.log.add(process.title, 'job', 'processTitle');
			next();
		}
	};
	init.add(step_processTitle);
	var step_repl = {
		id: 'repl',
		executor: function(next, thisEscalator) {
			thisEscalator.thisNgether = thisNgether;
			minions.openSocktREPL(thisNgether.id, thisNgether.config.replPort);
			thisNgether.log.add('REPL live on port: ' + thisNgether.config.replPort, 'job', 'init');
			next();
		}
	};
	init.add(step_repl);
	var step_understandPubSubs = {
		id: 'understandPubSubs',
		executor: function(next, thisEscalator) {
			thisNgether.meshBubPubSub = new _bubPubSub('mesh');
			thisNgether.meshBubPubSub.defaults.debugging = (thisNgether.config.loggingConfig.log2console === true) ? 1 : 0;
			thisNgether.meshBubPubSub.defaults.throwErrors = true;
			thisNgether.meshBubPubSub.subscribe(
				'/toMesh/',
				thisNgether._bubPubSubBridge_ToMesh,
				{ getBubbles: true, scope: thisNgether },
				'bubPubSubBridge_ToMesh'
			);
			thisNgether._bubPubSubBridge_FromMesh(next);
		}
	};
	init.add(step_understandPubSubs);
	
	var defaultPath = __dirname + '/plugins/';
	for (var n=0; n<thisNgether.config.activePlugins.length; n++) {
		init.add(thisNgether.loadPlugin(thisNgether.config.activePlugins[n]));
	}
	var step_listenAsClient = {
		id: 'listenAsClient',
		executor: function(next, thisEscalator) {
			thisNgether.subscribeToClientMessages();
			thisNgether.log.add('outgoing connections listen to messages now!', 'job', 'init');
			next();
		}
	};
	init.add(step_listenAsClient);
	var step_socketServer = {
		id: 'socketServer',
		delay: 1000,
		executor: function(next, thisEscalator) {
			thisNgether.startSocketServer(thisNgether.config.socketServer.port);
			thisNgether.log.add('websocket-node server listening on port ' + thisNgether.config.socketServer.port, 'job', 'init');
			next();
		}
	};
	init.add(step_socketServer);
	var step_initComplete = {
		id: 'initComplete',
		executor: function(next, thisEscalator) {
			thisNgether.log.add('[ngetherSpot] initiated.');
			if (typeof callback === 'function') callback(thisNgether);
			next();
		}
	};
	init.add(step_initComplete);
	var step_afterInit = {
		id: 'afterInit',
		executor: function(next, thisEscalator) {
			if (typeof afterInit === 'function') afterInit(thisNgether);
			next();
		}
	};
	init.add(step_afterInit);
	var step_runInitialConnects = {
		id: 'runInitialConnects',
		delay: 1000,
		executor: function(next, thisEscalator) {
			thisNgether.runInitialConnects();
			next();
		}
	};
	init.add(step_runInitialConnects);
	init.start();
	return true;
};




// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
// --------------- bubPubSub stuff 
// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
/* 
	example of how to propagate a local bubpubsub:
	ngether.bridgeTopic('/bla', ['spots'], {}, localBubPubSub);
	ngether.localBubPubSub.publish('/bla/#########################################################################################', { a:1 }, {}, 'meee');
*/
ngether.prototype.bridgeTopic = function(topic, targetPoolIdArray, subscribeOptions, bubPubSubInstanceToBridgeToNgether) {
	var thisNgether = this;
	if (typeof thisNgether.bridgedTopics !== 'object') thisNgether.bridgedTopics = {};
	if (
		(typeof bubPubSubInstanceToBridgeToNgether !== 'object' || bubPubSubInstanceToBridgeToNgether === null)
		&& typeof thisNgether.localBubPubSub === 'object'
	) {
		bubPubSubInstanceToBridgeToNgether = thisNgether.localBubPubSub;
	}
	if (typeof bubPubSubInstanceToBridgeToNgether !== 'object') return false;
	minions.defaultTo(subscribeOptions, {});
	var subscription = bubPubSubInstanceToBridgeToNgether.subscribe(
		topic,
		function(data, currentTopic, publisher, onReply, subscriptionIdObject) {
			if (typeof data.ngetherBridged === 'boolean' && data.ngetherBridged === true) return false;
			data.ngetherBridged = true;
			data.ngetherBridgedBy = thisNgether.id;
			thisNgether.broadcast(data.originalTopic, data, targetPoolIdArray);
			return true;
		},
		subscribeOptions,
		'ngetherBridgedTopic_' + topic
	);
	thisNgether.bridgedTopics[subscription.id] = { id: subscription.id, bubPubSubInstance: bubPubSubInstanceToBridgeToNgether, subscription: subscription };
	return thisNgether.bridgedTopics[subscription.id];
};

ngether.prototype.bridgedByMe = function(pubData) {
	return (typeof pubData.ngetherBridged === 'boolean' && pubData.ngetherBridged === true && pubData.ngetherBridgedBy === this.id);
};


/* example of how to stop propagation of a local bubpubsub:
	.. i expect the topic was bridged before...
	ngether.unbridgeTopic('/bla', 'spots', {}, localBubPubSub);
	ngether.meshBubPubSub.publish('/toMesh/spots/bla/#########################################################################################', { a:1 }, {}, 'meee');
*/
ngether.prototype.unbridgeTopic = function(bridgeId) {
	if (typeof bridgeId === 'object' && typeof bridgeId.id === 'string') bridgeId = bridgeId.id;
	if (typeof thisNgether.bridgedTopics !== 'object' || typeof thisNgether.bridgedTopics[bridgeId] !== 'object') {
		return false;
	}
	thisNgether.bridgedTopics[bridgeId].bubPubSubInstance.unsubscribe(thisNgether.bridgedTopics[bridgeId].subscription);
	delete thisNgether.bridgedTopics[bridgeId];
	return true;
};


/* **************************************
 *
 * method: ngether.prototype._bubPubSubBridge_ToMesh
 *	used internally. no use to be called from the outside!
 *	here, all bubpubsub publications starting with /toMesh are collected and sent 
 *	out to targeted spots/hubs 
 * 
 * parameters:
 *	publication {object} - the bubPubSub publication object
 *  caughtTopic {string} - which topic did we actually catch
 *	sender {string||object} - the sender of the publication
 *
 * returns:
 *	sentTo {array} - an array containing all connections that the publication was forwarded to.
 *
 * *********************************** */
ngether.prototype._bubPubSubBridge_ToMesh = function(publication, caughtTopic, sender) {
	var sentTo = [];
	// if (typeof this.log !== 'object') console.log(this);
	this.log.add('toMesh : ' + publication.originalTopic, 'plain', '_bubPubSubBridge_ToMesh');
	var topic = publication.originalTopic = publication.originalTopic.replace(/^\/toMesh\//, '/').replace('//', '/', 'gi');
	for (var n in this.connections) {
		if (typeof this.connections[n].ngether !== 'object' || typeof this.connections[n].ngether.partnerConfig !== 'object') {
			// scrap debug
			// console.log('------------WRONG########');
			// console.log(this.connections[n].ngether);
			continue;
		}
		var connectionId = n;
		var partnerId = (typeof this.connections[n].ngether.partnerConfig.id === 'string') ? this.connections[n].ngether.partnerConfig.id : '*';
		var poolIds = (typeof this.connections[n].ngether.partnerConfig.poolIds === 'object') ? this.connections[n].ngether.partnerConfig.poolIds : [];
		var isAddressedToPoolId = false;
		for (var i=0; i< poolIds.length; i++) {
			if (topic.indexOf('/' + poolIds[i] + '/') === 0) {
				isAddressedToPoolId = true;
				break;
			}
		}
		if (isAddressedToPoolId || topic.indexOf('/' + partnerId + '/') === 0 || topic.indexOf('/' + connectionId + '/') === 0) {
			this.connections[n].sendUTF(JSON.stringify({ cmd: 'bubPubSub', data: publication }));
			sentTo.push(this.connections[n]);
			this.log.add('{' + topic + '} sent to : {' + partnerId + ' @ ' + n + '}', 'announce', '_bubPubSubBridge_ToMesh');
		} else {
			/* console.log('/' + connectionId + '/');
			this.log.add('failed to find matching target connections for this topic: {' + topic + '}', 'error', '_bubPubSubBridge_ToMesh'); */
		}
	}
	return sentTo;
};


/* **************************************
 *
 * method: ngether.prototype._bubPubSubBridge_FromMesh
 *	used internally. no use to be called from the outside!
 *	here, all bubpubsub publications starting with /fromMesh are collected and sent 
 *	to ngethers local bubPubSub
 * 
 * parameters:
 *	callback {function} - what to do after the bridge has been established
 *
 * returns:
 *	true {boolean} - blind indicator that the method execution was completed
 *
 * *********************************** */
ngether.prototype._bubPubSubBridge_FromMesh = function(callback) {
	var thisNgether = this;
	this.commandHandlers.__bubPubSub = function(incomingSocket, msgObject) {
		thisNgether.log.add('received bubPubSub from mesh ! ' + msgObject.data.originalTopic, 'job', '_bubPubSubBridge_FromMesh');
		thisNgether.meshBubPubSub.publish(
			'/fromMesh' + msgObject.data.originalTopic,
			msgObject.data,
			{ scope: thisNgether, bubble: true, persist: false, silent: !thisNgether.config.loggingConfig.log2console},
			incomingSocket
		);
	};
	thisNgether.log.add('understanding command bubPubSub !', 'job', '_bubPubSubBridge_FromMesh');
	if (typeof callback === 'function') callback();
	return true;
};


/* **************************************
 *
 * method: ngether.prototype._bubPubSubBridge_ToLocal
 *	used internally. no use to be called from the outside!
 *	this picks up all ngether local pubsub publications starting /fromMesh are collected and 
 *	republishes them to the aLocalBubPubSubInstance given.
 * 
 * parameters:
 *	aLocalBubPubSubInstance {object} - the bubPubSub target object of the app using ngether. all /fromMesh publications will be re-published there.
 *  callback {function} - what to do after the bridge has been established
 *
 * returns:
 *	true {boolean} - blind indicator that the method execution was completed
 *
 * *********************************** */
ngether.prototype._bubPubSubBridge_ToLocal = function(aLocalBubPubSubInstance, callback) {
	var thisNgether = this;
	thisNgether.localBubPubSub = aLocalBubPubSubInstance;
	thisNgether.meshBubPubSub.subscribe(
		'/fromMesh',
		function(data, currentTopic, publisher, onReply, subscriptionIdObject) {
			aLocalBubPubSubInstance.publish(
				data.originalTopic.replace(/^\/fromMesh\/.*?\//, '/').replace('//', '/', 'gi'),
				data,
				{ silent: !thisNgether.config.loggingConfig.log2console },
				publisher
			);
		},
		{},
		'_bubPubSubBridge_ToLocal'
	);
	thisNgether.log.add('bridge to local bubPubSub installed!', 'job', 'init');
	if (typeof callback === 'function') callback();
	return true;
};




// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
// --------------- service methods about connections
// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
ngether.prototype.getConnectedPartners = function(needToBeAuthenticated, direction) {
	minions.defaultTo(needToBeAuthenticated, false);
	var partners = {};
	for (var i in this.connections) {
		var thisConn = this.connections[i];
		if (typeof direction === 'string' && thisConn.ngether.direction !== direction) continue;
		if (needToBeAuthenticated === true && thisConn.ngether.authenticated !== true) continue;
		partners[thisConn.ngether.partnerConfig.id] = thisConn.ngether.partnerConfig;
	}
	return partners;
};


ngether.prototype.getClientList = function(needToBeAuthenticated) {
	minions.defaultTo(needToBeAuthenticated, false);
	var clients = this.getConnectedPartners(needToBeAuthenticated, 'incoming');
	return clients;
};


ngether.prototype.getConnection = function(partnerId, state) {
	state = minions.defaultTo(state, 'open');
	for (var n in this.connections) {
		if (
			typeof this.connections[n] !== 'undefined' 
			&& this.connections[n].ngether.partnerConfig.id === partnerId
			&& this.connections[n].state === state
		) {
			return this.connections[n];
		}
	}
	return false;
};

ngether.prototype.isConnectedTo = function(partnerId, connectionIdToExclude) {
	for (var n in this.connections) {
		if (n === connectionIdToExclude) continue;
		if (
			typeof this.connections[n] !== 'undefined' 
			&& typeof this.connections[n].ngether !== 'undefined' 
			&& typeof this.connections[n].ngether.partnerConfig !== 'undefined' 
			&& this.connections[n].ngether.partnerConfig.id === partnerId) return this.connections[n];
	}
	return false;
};


ngether.prototype.cleanupDuplicateConnections = function() {
  var connectedPartners = [];
  var disconnectedPartners = [];
  for (var n in this.connections) {
    var connection = this.connections[n];
    if (connection.state !== 'open') disconnectedPartners.push(connection.ngether.partnerConfig.id);
    else connectedPartners.push(connection.ngether.partnerConfig.id);
  }
  for (var i=0; i < connectedPartners.length; i++) {
    var closedDupe = this.getConnection(connectedPartners[i], 'closed');
		if (typeof closedDupe === 'object') {
			this.log.add('cleaned up lost connection to {' + connectedPartners[i] + '}', 'error', 'receiveMeshWorkNodes');
			this.destroyConnection(connection.id, 2001, 'duplicate connection');
		}
  }
  return true;
};


ngether.prototype.destroyConnection = function(connectionId, reasonCode, description) {
	if (
		typeof this.connections[connectionId] === 'object'
	) {
		this.log.add('destroyed connection {' + connectionId + '}', 'job', 'ngether.destroyConnection');
		if (typeof reasonCode === 'boolean' && reasonCode === false) {
			return delete this.connections[connectionId];
		} else {
			reasonCode = minions.defaultTo(reasonCode, 2000);
			description = minions.defaultTo(description, 'destroy connection forced');		
			this.connections[connectionId].drop(reasonCode, description);
		} 
		return true;
	}
	return false;
};


ngether.prototype.resetConnection = function(connectionId) {
	var thisNgether = this;
	var target = this.connections[connectionId].ngether.target;
	this.destroyConnection(connectionId);
	setTimeout(
		function() {
			thisNgether.connectTo(target);
		},
		1000
	);
};


ngether.prototype.listen = function(port, options) {
	var thisNgether = this;
	var server = http.createServer(
		function(request, response) {
			thisNgether.log.add('received connection request for {' + request.url + '}', 'announce', 'ng.listen.request');
			response.writeHead(404);
			response.end();
		}
	);
	server.listen(
		port, 
		function() {
			thisNgether.log.add('http server is listening on port {' + port + '}', 'announce', 'ng.listen');
		}
	);
	var serverOptions = minions.extendShallow(
		false, 
		thisNgether.defaultConfig(), 
		[
			thisNgether.defaultConfig().webSocketServerConfig,			
			{
				httpServer: server,
				autoAcceptConnections: false
			}
		]
	);
	var wsServer = new WebSocketServer(
		serverOptions
	);
	function originIsAllowed(request) {
		// put logic here to detect whether the specified origin is allowed.
		thisNgether.log.add('allowing request from origin {' + request.origin + '}', 'announce', 'ng.listen');
		if (typeof request.resourceURL.query.partnerSpotId !== 'string') return false;
		if (typeof request.resourceURL.query.connectionId !== 'string') return false;
		return true;
	};	
	thisNgether.router = new WebSocketRouter();
	thisNgether.router.attachServer(wsServer);
	thisNgether.router.mount(
		'*', 
		'ngether-protocol', 
		function(request) {
			// DEBUG
			//console.log(request);
			if (
				originIsAllowed(request) !== true
				|| typeof request.resourceURL.query.partnerSpotId !== 'string'
				|| typeof request.resourceURL.query.connectionId !== 'string'
				|| thisNgether.isConnectedTo(request.resourceURL.query.partnerSpotId) !== false
			) {
				// Make sure we only accept requests from an allowed origin
				request.reject();
				thisNgether.log.add('connection rejected from origin {' + request.origin + '}', 'announce', 'ng.listen.request');
				thisNgether.meshBubPubSub.publish(
					'/ngetherServer/request/rejected/',
					{ request: request },
					{},
					'ng.request.reject'
				);
				return;
			}
			var cookies = [];
			var connection = request.accept(request.origin, cookies);
			var now = new Date().getTime();
			connection.ngether = {};
			connection.ngether.connectedAt = now;
			connection.ngether.partnerSpotId = request.resourceURL.query.partnerSpotId; 
			connection.ngether.connectionId = request.resourceURL.query.connectionId; 
			connection.ngether.direction = 'incoming';
			connection.ngether.clientIp = connection.remoteAddress;
			connection.ngether.partnerConfig = { id: connection.ngether.partnerSpotId, type: 'unknown', host: connection.ngether.clientIp, port: 0, poolIds: [] };
			connection.ngether.authenticated = false;
			thisNgether.connections[connection.ngether.connectionId] = connection;
			thisNgether.log.add('connection accepted from origin {' + request.origin + '}', 'announce', 'ng.listen.request');
			connection.on(
				'message', 
				function(message) {
          if (message.type === 'utf8') {
						thisNgether.log.add('received MESSAGE in UTF8 {' + message.utf8Data.length + 'bytes}', 'announce', 'ng.listen.message');
					}
					else if (message.type === 'binary') {
						thisNgether.log.add('received MESSAGE in BINARY {' + message.binaryData.length + 'bytes}', 'announce', 'ng.listen.message');
					}
					thisNgether.meshBubPubSub.publish(
						'/ngetherServer/receivedMessage/' + message.type + '/' + connection.ngether.connectionId,
						{ message: message, connection: connection },
						{},
						'ng.listen.message'
					);
				}
			);
			connection.on(
				'close', 
				function(reasonCode, description) {
					thisNgether.destroyConnection(connection.ngether.connectionId, false);
					thisNgether.log.add('connection closed from {' + connection.ngether.connectionId + '@' + connection.remoteAddress + '}', 'announce', 'ng.listen.close');
					thisNgether.meshBubPubSub.publish(
						'/ngetherServer/connection/closed/' + connection.ngether.connectionId,
						{ reasonCode: reasonCode, description: description, connection: connection },
						{},
						'ng.connection.close'
					);
				}
			);
			// --- tell everyone about the new connection	
			thisNgether.meshBubPubSub.publish(
				'/ngetherServer/connection/accepted/' + request.resourceURL.query.connectionId,
				{ request: request, connection: connection },
				{},
				'ng.connection.open'
			);
		}
	);
	
	return wsServer;
};

// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
// --------------- connections as client also get messages ...
// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
ngether.prototype.subscribeToClientMessages = function() {
	var thisNgether = this;
	thisNgether.subscriptions.messageIncomingUtf8Client = thisNgether.meshBubPubSub.subscribe(
		'/ngetherClient/receivedMessage/utf8/',
		function(pubData) {
			var thisConnection = pubData.connection;
			var message = pubData.message;
			thisNgether.socketMessageHandlerUTF8(thisConnection, message);
		},
		{},
		'ng.message.utf8'
	);
	thisNgether.subscriptions.messageIncomingBinaryClient = thisNgether.meshBubPubSub.subscribe(
		'/ngetherClient/receivedMessage/binary/',
		function(pubData) {
			var thisConnection = pubData.connection;
			var message = pubData.message;
			thisNgether.socketMessageHandlerBinary(thisConnection, message);
		},
		{},
		'ng.message.binary'
	);
	return true;
};


// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
// --------------- the server part of each ngether spot
// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
ngether.prototype.startSocketServer = function(port) {
	if (typeof port !== 'number') port = 9999;
	var thisNgether = this;
	thisNgether.socketServer = thisNgether.listen(port);
	thisNgether.subscriptions.incomingConnections = thisNgether.meshBubPubSub.subscribe(
		'/ngetherServer/connection/accepted/',
		function(pubData) {
			var thisConnection = pubData.connection;
			var thisRequest = pubData.request;
			thisNgether.log.add('client ' + thisConnection.ngether.partnerSpotId + ' connected via socket ' + thisConnection.ngether.connectionId + ' from ' + thisConnection.ngether.partnerConfig.host, 'announce', 'socketServer');
		},
		{},
		'ng.incomingConnections'
	);
	thisNgether.subscriptions.closingConnections = thisNgether.meshBubPubSub.subscribe(
		'/ngetherServer/connection/closed/',
		function(pubData) {
		},
		{},
		'ng.closingConnections'
	);
	thisNgether.subscriptions.messageIncomingUtf8 = thisNgether.meshBubPubSub.subscribe(
		'/ngetherServer/receivedMessage/utf8/',
		function(pubData) {
			var thisConnection = pubData.connection;
			var message = pubData.message;
			thisNgether.socketMessageHandlerUTF8(thisConnection, message);
		},
		{},
		'ng.message.utf8'
	);
	thisNgether.subscriptions.messageIncomingBinary = thisNgether.meshBubPubSub.subscribe(
		'/ngetherServer/receivedMessage/binary/',
		function(pubData) {
			var thisConnection = pubData.connection;
			var message = pubData.message;
			thisNgether.socketMessageHandlerBinary(thisConnection, message);
		},
		{},
		'ng.message.binary'
	);
	thisNgether.connectionCleanupInterval = setInterval(
		thisNgether.cleanupDuplicateConnections,
		5000
	);
};



ngether.prototype.reconnect = function(client, targetConnectionUrl, target) {
	var thisNgether = this;
	if (typeof thisNgether.config.reconnectInterval !== 'number') thisNgether.config.reconnectInterval = 2000;
	if (typeof thisNgether.config.maxConnectAttempts !== 'number') thisNgether.config.maxConnectAttempts = 100;
	/* if (thisNgether.attemptingConnectionsTo.indexOf(target.id) > -1) {
		thisNgether.log.add('NOT connecting to [' + target.host + ':' + target.port + '] because [ALREADY TRYING!]', 'error', 'ng.client.reconnect');
		return false;
	} */
	if (typeof client.ngether.connectionInterval !== 'undefined') clearInterval(client.ngether.connectionInterval);
	client.ngether.connectionInterval = setInterval(
		function() {
			if (thisNgether.isConnectedTo(target.id) !== false) {
				clearInterval(client.ngether.connectionInterval);
				thisNgether.log.add('NOT connecting to [' + target.host + ':' + target.port + '] because [ALREADY CONNECTED]', 'error', 'ng.client.reconnect');
				return false;
			}
			if (
				(typeof client.connection === 'undefined' || client.connection.state === 'closed')
				||
				(thisNgether.attemptingConnectionsTo.indexOf(target.id) > -1)
			) {
				thisNgether.attemptingConnectionsTo.push(target.id);
				client.connect(targetConnectionUrl, 'ngether-protocol', thisNgether.config.socketServer.host);
				client.ngether.connectAttempts++;
				if (client.ngether.connectAttempts > thisNgether.config.maxConnectAttempts) {
					clearInterval(client.ngether.connectionInterval);
					thisNgether.log.add('NOT connecting to [' + target.host + ':' + target.port + '] because [MAX CONNECTION ATTEMPTS REACHED]', 'error', 'ng.client.reconnect');
				}
			} else {
				clearInterval(client.ngether.connectionInterval);
				client.ngether.connectAttempts = 0;
			}
		},
		thisNgether.config.reconnectInterval
	);
};

// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
// --------------- the client part of each ngether spot
// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
ngether.prototype.connectTo = function(target, options, callback) {
	var thisNgether = this;
	try {
		if (thisNgether.isConnectedTo(target.id) !== false) {
			thisNgether.log.add('NOT connecting to [' + target.host + ':' + target.port + '] because [ALREADY CONNECTED]', 'error', 'ng.client.connectTo');
			return false;
		}
		var client = new WebSocketClient({
			maxReceivedMessageSize: thisNgether.config.webSocketClientConfig.maxReceivedMessageSize,
			maxReceivedFrameSize : thisNgether.config.webSocketClientConfig.maxReceivedFrameSize,
			fragmentOutgoingMessages : thisNgether.config.webSocketClientConfig.fragmentOutgoingMessages,
			fragmentationThreshold : thisNgether.config.webSocketClientConfig.fragmentationThreshold,
			assembleFragments  : thisNgether.config.webSocketClientConfig.assembleFragments,
			closeTimeout  : thisNgether.config.webSocketClientConfig.closeTimeout
		});
		client.ngether = {};
		client.ngether.target = target;
		client.ngether.connectAttempts = 0;
		thisNgether.attemptingConnectionsTo.push(target.id);
		var connectionId = minions.randomString(12, true, true, true);
		var targetConnectionUrl = 'ws://' + target.host + ':' + target.port + '/ngether?connectionId=' + connectionId + '&' + 'partnerSpotId=' + thisNgether.config.id;
		/* thisNgether.connections[connectionId] = {
			ngether: {
				partnerSpotId: target.id,
				partnerConfig: target,
				connectedAt: 0,
				direction: 'outgoing',
				options: (typeof options === 'object') ? options : this.config.defaultSocketOptions
			}
		}; */
		client.on(
			'connectFailed', 
			function(error) {
				thisNgether.log.add('connection to [' + target.host + ':' + target.port + '] failed because [' + error.toString() + ']', 'error', 'ng.client.error');
				//if (typeof client.ngether.connectionInterval !== 'undefined') clearInterval(client.ngether.connectionInterval);
				// scrap debug
				// console.log(client.ngether);
				setTimeout(
					function() {
						if (
							thisNgether.isConnectedTo(target.id) !== false
							&& thisNgether.attemptingConnectionsTo.indexOf(target.id) === -1
						) {
							thisNgether.log.add('NOT connecting to [' + target.host + ':' + target.port + '] because [ALREADY CONNECTED]', 'error', 'ng.client.connectTo');
						} else {
							thisNgether.reconnect(client, targetConnectionUrl, target);
						}
					},
					6000
				);
			}
		);
		client.on(
			'connect',
			function(connection) {
				var now = new Date().getTime();
				client.connection = connection;
				connection.ngether = {};
				connection.ngether.connectedAt = now;
				connection.ngether.partnerSpotId = target.id;
				connection.ngether.connectionId = connectionId;
				// in outgoing, auth means we told the other side about us...
				connection.ngether.authenticated = false;
				connection.ngether.partnerConfig = target;
				connection.ngether.direction = 'outgoing';
				connection.ngether.options = (typeof options === 'object') ? options : this.config.defaultSocketOptions;
				thisNgether.connections[connection.ngether.connectionId] = connection;
				var idx = thisNgether.attemptingConnectionsTo.indexOf(target.id);
				thisNgether.attemptingConnectionsTo.splice(idx, 1);
        thisNgether.log.add('############################# new connection {' + connection.ngether.connectionId + '}', 'error', 'ng.client.connect');
				connection.on(
					'error', 
					function(error) {
						thisNgether.log.add('connection error to {' + connection.remoteAddress + '} => ' + error.toString(), 'error', 'ng.client.error');
						thisNgether.meshBubPubSub.publish(
							'/ngetherClient/connection/error/' + connection.ngether.connectionId,
							{ error: error, connection: connection },
							{},
							'ng.client.error'
						);
					}
				);
				connection.on(
					'close', 
					function(reasonCode, description) {						
						thisNgether.destroyConnection(connection.ngether.connectionId, false);
						thisNgether.log.add('connection closed to {' + connection.remoteAddress + '} with code [' + reasonCode + ']', 'announce', 'ng.client.close');
						thisNgether.meshBubPubSub.publish(
							'/ngetherClient/connection/closed/' + connection.ngether.connectionId,
							{ reasonCode: reasonCode, description: description, connection: connection },
							{},
							'ng.client.close'
						);
						if (typeof thisNgether.config.autoReconnect !== 'boolean') thisNgether.config.autoReconnect = true;
						if (
							// our code for duplicate connection
							reasonCode !== 2001 
							// internal code for going away
							&& reasonCode !== 1001
							&& thisNgether.config.autoReconnect === true 							
						) {
							thisNgether.reconnect(client, targetConnectionUrl, target);
						}
					}
				);
        connection.on(
					'message', 
					function(message) {
            if (message.type === 'utf8') {
							thisNgether.log.add('received MESSAGE in UTF8 {' + message.utf8Data.length + 'bytes}', 'announce', 'ng.client.message');
						}
						else if (message.type === 'binary') {
        			thisNgether.log.add('received MESSAGE in BINARY {' + message.binaryData.length + 'bytes}', 'announce', 'ng.client.message');
						}
				    thisNgether.meshBubPubSub.publish(
							'/ngetherClient/receivedMessage/' + message.type + '/' + connection.ngether.connectionId,
							{ message: message, connection: connection, client: client },
							{},
							'ng.client.message'
						);
					}
				);
				// connection.ping('{ts:' + new Date().getTime() + '}');
				// --- tell everyone about this
				thisNgether.meshBubPubSub.publish(
					'/ngetherClient/connection/connect/' + connection.ngether.connectionId,
					{ client: client, connection: connection },
					{},
					'ng.client.connect'
				);
			}
		);
		var conn = client.connect(targetConnectionUrl, 'ngether-protocol', thisNgether.config.socketServer.host);				
	} catch(err) {
		exceptionHandler(err);
		return;
	}
};




// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
// --------------- handling of socket messages
// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
ngether.prototype.socketMessageHandlerUTF8 = function(thisConnection, msg) {
	var thisNgether = this;
	var msgObject = null;
	try {
		msgObject = JSON.parse(msg.utf8Data);
		if (typeof msgObject.cmd !== 'string' || typeof thisNgether.commandHandlers['__' + msgObject.cmd] !== 'function') {
			thisNgether.log.add('received message without recognized cmd from {' + thisConnection.id + '} with sid {' + thisConnection.ngether.partnerSpotId + '}', 'error', 'socketMessageHandlerUtf8');
			// scrap debug
			// console.log(msgObject);
			return false;
		}
		if (thisConnection.ngether.authenticated !== true && typeof thisNgether.commandHandlers.__auth === 'undefined') thisConnection.ngether.authenticated = true;
		if (
			thisConnection.ngether.authenticated === true 
			|| msgObject.cmd === 'auth' 
			|| ( thisConnection.ngether.direction === 'outgoing' && msgObject.cmd === 'bubPubSub' ) //  && msgObject.data.originalTopic.indexOf('authentication') > -1
		) {
			var handled = thisNgether.commandHandlers['__' + msgObject.cmd](thisConnection, msgObject);
		} else {
			thisNgether.log.add('received message from non-authenticated socket {' + thisConnection.id + '} with sid {' + thisConnection.ngether.partnerSpotId + '}', 'error', 'socketServer.onMessage');
		}		
	} catch(err) {
		exceptionHandler(err);
	}
	return msgObject;
};
ngether.prototype.socketMessageHandlerBinary = function(thisConnection, msg) {
	var thisNgether = this;
	var msgObject = null;
	try {
		thisNgether.log.add('received binary message from {' + thisConnection.ngether.partnerSpotId + '} received {' + msg.binaryData.length + 'bytes}', 'announce', 'socketMessageHandlerBinary');
		thisNgether.meshBubPubSub.publish(
			'/ngether/receivedMessage/binary/' + thisConnection.ngether.connectionId,
			{ message: msg, connection: thisConnection },
			{},
			'ng.unifying.socketMessageHandlerBinary'
		); 
	} catch(err) {
		exceptionHandler(err);
	}
	return msgObject;
};


// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
// --------------- basic communication methods for mesh networking
// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
ngether.prototype.getTargetConnections = function(poolIds, excludedIds) {
	// --- finding targets
	var targets = [];
	for (var t in this.connections) {
		var add = true;
		if (excludedIds.indexOf(this.connections[t].ngether.partnerConfig.id) > -1) {
			add = false;
		} else if (typeof poolIds === 'object' && typeof poolIds.length === 'number' && poolIds.length > 0) {
			add = false;
			if (
				typeof this.connections[t].ngether.partnerConfig.poolIds !== 'object'
				|| typeof this.connections[t].ngether.partnerConfig.poolIds instanceof Array === false
			) {
				this.log.add('NO POOLIDS sent by a partner. PLEASE FIX ITS CONFIG: ' + this.connections[t].ngether.partnerConfig.id, 'red', 'ngether.getTargetConnections');
				this.connections[t].ngether.partnerConfig.poolIds = [];
			}
			for (var n in poolIds) {
				if (
					this.connections[t].ngether.partnerConfig.poolIds.indexOf(poolIds[n]) > -1	
				) {
					add = true;
					break;
				}
			}
		}
		if (this.connections[t].ngether.authenticated !== true) {
			add = false;
		}
		if (add === true) targets.push(this.connections[t].ngether.partnerConfig.id);
	}
	return targets;
};

ngether.prototype.limitTargets = function(targets, limit) {
	while (targets.length > limit) {
		var pos = Math.floor(Math.random()*targets.length);
		targets.splice(pos,1);
	}
	return targets;
};

ngether.prototype.emit = function(topics, data, poolIds, limit) {
	// --- normalizing arguments
	if (typeof topics === 'string') topics = [ topics ];
	// collect targets
	var targets = this.getTargetConnections(poolIds, []);
	// we are in emit mode, where we publish to ourselves as well
	targets.push(this.id);
	// introduce limit RANDOMLY
	if (typeof limit === 'number') targets = this.limitTargets(targets, limit);
	// --- publish
	var publications = this._publishingloop('emit', topics, targets, data);
	return publications;
};

ngether.prototype.broadcast = function(topics, data, poolIds, limit) {
	// --- normalizing arguments
	if (typeof topics === 'string') topics = [ topics ];
	// collect targets
	var targets = this.getTargetConnections(poolIds, [this.id]);
	
	// introduce limit RANDOMLY
	if (typeof limit === 'number') targets = this.limitTargets(targets, limit);
	// --- publish
	var publications = this._publishingloop('broadcast', topics, targets, data);
	return publications;
};

ngether.prototype.tell = function(topics, data, targets) {
	// --- normalizing arguments
	if (typeof topics === 'string') topics = [ topics ];
	// set targets
	if (typeof targets === 'string') targets = [ targets ];
	// --- publish
	var publications = this._publishingloop('tell', topics, targets, data);
	return publications;
};


ngether.prototype.listenTo = function(topics, receiverIds, handler) {
	// ---normalizing arguments
	if (typeof receiverIds === 'function') {
		handlers = receiverIds;
		receiverIds = ['*'];
	}
	if (typeof topics === 'string') topics = [ topics ]
	if (typeof receiverIds === 'string') receiverIds = [ receiverIds ];
	else if (typeof receiverIds === 'undefined') receiverIds = [];
	// ---vars
	var subscriptions = [];
	// ---the subsription loop
	for (var n = 0; n < topics.length; n++) {
		for (var k = 0; k < receiverIds.length; k++) {
			var subId = 'listener_' + minions.randomString(12);
			var a = receiverIds[k] + '/';
			if (receiverIds[k] === '*' || receiverIds[k] === '') {
				a = '';
			}
			var b = '/' + topics[n] + '/';
			if (topics[n] === '*' || topics[n] === '') {
				b = '';
			}
			var topic = ('/fromMesh/' + a + b).replace('//', '/', 'gi'); 

			this.subscriptions[subId] = this.meshBubPubSub.subscribe(
				topic,
				handler,
				{ getBubbles:true },
				subId
			);
			subscriptions.push(this.subscriptions[subId]);
		}
	}
	return subscriptions;
};

ngether.prototype.unlisten = function(listener){
   this.meshBubPubSub.unsubscribe(listener);
};

ngether.prototype._publishingloop = function(pubType, topics, targets, data) {
	var thisNgether = this;
	var publications = [];
	data.ngether = {
		publicationSource: thisNgether.id,
		timestamp: new Date().getTime()
	};
	// --- publishing loop
	for (var n = 0; n < topics.length; n++) {
		for (var k = 0; k < targets.length; k++) {
			// bad hack .. check for auth
			if (targets[k] === 'notSet') continue;
			var pubId = data.ngether.pubId = thisNgether.id + '_' + pubType + '_' + minions.randomString(8, false, true, true);
			data.ngether.publicationTarget = targets[k];
			var thisTopic =  '/toMesh/' + targets[k] + '/' + topics[n];
			thisTopic = thisTopic.replace('//', '/', 'gi');
			if (thisNgether.id === targets[k]) {
				var pub = thisNgether.meshBubPubSub.publish(
					('/fromMesh/' + targets[k] + '/' + topics[n]).replace('//', '/', 'gi'),
					data,
					{ scope: thisNgether, silent: !thisNgether.config.loggingConfig.log2console },
					pubId
				);
			} else {
				var pub = thisNgether.meshBubPubSub.publish(
					thisTopic,
					data,
					{ scope: thisNgether, silent: !thisNgether.config.loggingConfig.log2console },
					pubId
				);
			}			
			publications.push(pub);
		}
	}
	return publications;
};


function getHigherSemanticVersion(v1, v2) {
	var _v1 = v1.split('.');
	var _v2 = v2.split('.');
	for (var i=0; i<_v1.length; i++) {
		var n_v1 = Number(_v1[i]);
		var n_v2 = Number(_v2[i]);
		if (n_v1 > n_v2) {
			return v1;
		} else if (n_v1 < n_v2) {
			return v2;
		}
	}
	return false;
};


// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
// --------------- hello world
// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
module.exports = ngether;
console.log('[ngether] module loaded.');
