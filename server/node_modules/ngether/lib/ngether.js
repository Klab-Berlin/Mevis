/*
	tests in REPL:	
	
	// --- TEST telling named meshNodes
	ngether.tell('desktops/sync/bla', { a:1, b:2 }, [ 'ngetherSpot02_9992_1222' ]);
	ngether.tell('desktops/sync/bla', { a:1, b:2 }, [ 'ngetherSpot02_9992_1222', 'ngetherSpotF01_9993_1223' ] );
	
	// --- TEST broadcasting
	ngether.broadcast('desktops/sync/broadcasting', { a:1, b:2 } );
	
	// --- TEST emitting
	ngether.emit('desktops/sync/emit', { a:1, b:2 } ); 
	
	// --- TEST broadcasting filtering by poolIds
	ngether.broadcast('desktops/sync/broadcasting', { a:1, b:2 }, [ 'webserver' ] );
	ngether.broadcast('desktops/sync/broadcasting', { a:1, b:2 }, [ 'spots' ] );
	
	// --- TEST emitting filtering by poolIds
	ngether.emit('desktops/sync/broadcasting', { a:1, b:2 }, [ 'webserver' ] );
	ngether.emit('desktops/sync/broadcasting', { a:1, b:2 }, [ 'hubs' ] );
	ngether.emit('desktops/sync/broadcasting', { a:1, b:2 }, [ 'spots' ] );
	
	// --- TEST broadcast filtering by poolIds with a limit
	ngether.broadcast('desktops/sync/broadcasting', { a:1, b:2 }, [ 'webserver' ], 1 );
	ngether.broadcast('desktops/sync/broadcasting', { a:1, b:2 }, [ 'meshNode' ], 2 );
	
	// --- TEST emitting filtering by poolIds with a limit
	ngether.emit('desktops/sync/broadcasting', { a:1, b:2 }, [ 'webserver' ], 1 );
	ngether.emit('desktops/sync/broadcasting', { a:1, b:2 }, [ 'meshNode' ], 2 );
	
	
	// --- TEST eventBridges
	ngether.eventBridge(process, 'test', 'broadcast', process, process);
	process.on('test', function() { console.log('@@@@@@@@@@@@@@EVENT TEST @@@@@@@@@@@@@@@@@@@@@@'); console.log(arguments); } );
	process.emit('test', 1, 'b', 3, { d: 'a' });
	
	
*/
var fs = require('fs');
var classes = {
	_logger: require('./logger'),
	_bubPubSub: require('bubpubsub'),
	_mongodb: require('mongodb'),
	_sugar: require('./sugar'),
	_funcs: require('./funcs'),
	_engineIO: require('engine.io'),
	_engineIOclient: require('engine.io-client'),
};
var funcs = new classes._funcs();


// -------------- ngether base Object
var ngether = function() {
};


ngether.prototype.releaseData = function() {
	var releaseData = {
		authors: [ 'Toni Wagner' ],
		version: '0.2.3',
		data: 'Nov 30, 2012',
		license: 'MIT',
		contact: 'i@itsatony.com'
	};
	return releaseData;
};


/* **************************************
 *
 * method: ngether.prototype._bubPubSubBridge_ToMesh
 *	used internally. no use to be called from the outside!
 *	here, all bubpubsub publications starting with /toMesh are collected and sent 
 *	out to targeted spots/hubs 
 * 
 * parameters:
 *	publication {object} - the bubPubSub publication object
 *  caughtTopic {string} - which topic did we actually catch
 *	sender {string||object} - the sender of the publication
 *
 * returns:
 *	sentTo {array} - an array containing all connections that the publication was forwarded to.
 *
 * *********************************** */
ngether.prototype._bubPubSubBridge_ToMesh = function(publication, caughtTopic, sender) {
	var sentTo = [];
	// if (typeof this.log !== 'object') console.log(this);
	this.log.add('toMesh : ' + publication.originalTopic, 'plain', '_bubPubSubBridge_ToMesh');
	var topic = publication.originalTopic = publication.originalTopic.replace('/toMesh', '');
	for (var n in this.connections) {
		if (typeof this.connections[n].ngether !== 'object') continue;
		if (typeof this.connections[n].ngether.partnerConfig !== 'object') {
			console.log('------------WRONG########');
			console.log(this.connections[n].ngether);
			continue;
		}
		var partnerName = n;
		var socketId = (typeof this.connections[n].ngether.partnerConfig.id === 'string') ? this.connections[n].ngether.partnerConfig.id : '*';
		if (topic.indexOf('/' + socketId + '/') === 0 || topic.indexOf('/' + partnerName + '/') === 0) {
			this.connections[n].send(JSON.stringify({ cmd: 'bubPubSub', data: publication }));
			sentTo.push(this.connections[n]);
			// console.log(topic + ' sent to : ' + socketId + ' @ ' + n);
		} else {
			
		}
	}
	return sentTo;
};


/* **************************************
 *
 * method: ngether.prototype._bubPubSubBridge_FromMesh
 *	used internally. no use to be called from the outside!
 *	here, all bubpubsub publications starting with /fromMesh are collected and sent 
 *	to ngethers local bubPubSub
 * 
 * parameters:
 *	callback {function} - what to do after the bridge has been established
 *
 * returns:
 *	true {boolean} - blind indicator that the method execution was completed
 *
 * *********************************** */
ngether.prototype._bubPubSubBridge_FromMesh = function(callback) {
	var thisNgether = this;
	this.commandHandlers.__bubPubSub = function(incomingSocket, msgObject) {
		thisNgether.log.add('received bubPubSub from mesh ! ' + msgObject.data.originalTopic, 'job', '_bubPubSubBridge_FromMesh');
		thisNgether.meshBubPubSub.publish(
			'/fromMesh' + msgObject.data.originalTopic,
			msgObject.data,
			{ scope: thisNgether, bubble: true, persist: false, silent: !thisNgether.config.loggingConfig.log2console},
			incomingSocket
		);  
	};
	thisNgether.log.add('understanding command bubPubSub !', 'job', '_bubPubSubBridge_FromMesh');
	if (typeof callback === 'function') callback();
	return true;
};


/* **************************************
 *
 * method: ngether.prototype._bubPubSubBridge_ToLocal
 *	used internally. no use to be called from the outside!
 *	this picks up all ngether local pubsub publications starting /fromMesh are collected and 
 *	republishes them to the aLocalBubPubSubInstance given.
 * 
 * parameters:
 *	aLocalBubPubSubInstance {object} - the bubPubSub target object of the app using ngether. all /fromMesh publications will be re-published there.
 *  callback {function} - what to do after the bridge has been established
 *
 * returns:
 *	true {boolean} - blind indicator that the method execution was completed
 *
 * *********************************** */
ngether.prototype._bubPubSubBridge_ToLocal = function(aLocalBubPubSubInstance, callback) {
	var thisNgether = this;
	thisNgether.localBubPubSub = aLocalBubPubSubInstance;
	thisNgether.meshBubPubSub.subscribe(
		'/fromMesh',
		function(data, currentTopic, publisher, onReply, subscriptionIdObject) {
			aLocalBubPubSubInstance.publish(
				data.originalTopic.replace(/^\/fromMesh\/.*?\//, '/'),
				data,
				{ silent: !thisNgether.config.loggingConfig.log2console },
				publisher
			);
		},
		{},
		'_bubPubSubBridge_ToLocal'
	);
	thisNgether.log.add('bridge to local bubPubSub installed!', 'job', 'init');
	if (typeof callback === 'function') callback();
	return true;
};


ngether.prototype._publishingloop = function(pubType, topics, targets, data) {
	var thisNgether = this;
	var publications = [];
	data.ngether = {
		publicationSource: thisNgether.id,
		timestamp: new Date().getTime()
	};
	// --- publishing loop
	for (var n = 0; n < topics.length; n++) {
		for (var k = 0; k < targets.length; k++) {
			var pubId = data.ngether.pubId = this.id + '_' + pubType + '_' + funcs.makeId(12);
			var pub = this.meshBubPubSub.publish(
				'/toMesh/' + targets[k] + '/' + topics[n],
				data,
				{ scope: thisNgether, silent: !thisNgether.config.loggingConfig.log2console },
				pubId
			);
			publications.push(pub);
		}
	}
	return publications;
};


ngether.prototype.isConnectedTo = function(partnerId) {
	for (var n in this.connections) {
		if (this.connections[n].ngether.partnerConfig.id === partnerId) return n;
	}
	return false;
};


ngether.prototype.listConnections = function() {
	console.log('***** CONNECTIONS @ ' + new Date() + ' *****');
	for (var n in this.connections) {
		console.log('(' + this.connections[n].transport.readyState + ') [' + this.connections[n].ngether.direction + '@' + n + '] ==> ' + this.connections[n].ngether.partnerConfig.id);
	}
	return this.connections;
};


ngether.prototype.startSocketServer = function(port) {
	if (typeof port !== 'number') port = 9999;
	var thisNgether = this;
	this.socketServer = classes._engineIO.listen(port, {
		transports: [ 'websocket' ]
	});
	this.socketServer.on(
		'connection', 
		function (thisSocket) {
			var thisConn = thisSocket;
			thisConn.ngether = {};
			thisConn.ngether.direction = 'incoming';		
			thisConn.ngether.clientIp = thisConn.transport.request.connection.remoteAddress;
			thisConn.ngether.partnerConfig = { id: 'notSet', type: 'unknown', host: thisConn.ngether.clientIp, port: 0, poolIds: [] };
			thisNgether.connections[thisSocket.id] = thisConn;
			thisNgether.log.add('socket connected: ' + thisSocket.id, 'plain', 'socketServer');
			thisSocket.on(
				'close',
				function () {
					delete thisNgether.connections[thisSocket.id];
					thisNgether.log.add('socket disconnected: ' + thisSocket.id, 'plain', 'socketServer');
					delete thisSocket;
				}
			);
			thisSocket.on(
				'message',
				function(msg) {
					thisNgether.socketMessageHandler(thisSocket, msg);
				}
			);
		}
	);
	if (thisNgether.config.type === 'spot') {
		thisNgether.connectTo({
			id: thisNgether.config.id,
			type: thisNgether.config.type,
			host: 'localhost', 
			port: thisNgether.config.socketServer.port
		});
	}
};


ngether.prototype.socketMessageHandler = function(thisSocket, msg) {
	var thisNgether = this;
	this.log.add('socket message: ' + thisSocket.id + '', 'plain', 'socketServer');
	try {
		var msgObject = JSON.parse(msg);
		if (typeof msgObject.cmd !== 'string' || typeof thisNgether.commandHandlers['__' + msgObject.cmd] !== 'function') return;
		var handled = thisNgether.commandHandlers['__' + msgObject.cmd](thisSocket, msgObject);
	} catch(err) {
		exceptionHandler(err);
	}
};


ngether.prototype.reconnect = function(connection, interval) {
	var thisNgether = this;
	if (typeof interval !== 'number') interval = this.config.reconnectInterval;
	if (connection.ngether.direction !== 'outgoing') return false;
	connection.reconnectInterval = setInterval(
		function() {
			if (typeof connection === 'undefined') {
				clearInterval(connection.reconnectInterval);
			};
			if (connection.readyState === 'closed') {
				// console.log(new Date() + ' trying to reconnect');
				var target = connection.ngether.partnerConfig;
				var options = connection.ngether.options;
				thisNgether.connectTo(target, options);
				thisNgether.destroyConnection(connection);
				clearInterval(connection.reconnectInterval);
			}
		},
		interval
	);
	return connection.reconnectInterval;
};


ngether.prototype.destroyConnection = function(socket) {
	return delete this.connections[socket.id];
};


ngether.prototype.getTargetConnections = function(poolIds) {
	// --- finding targets
	var targets = [];
	for (var t in this.connections) {
		var add = true;
		if (typeof poolIds === 'object' && typeof poolIds.length === 'number' && poolIds.length > 0) {
			add = false;
			for (var n in poolIds) {
				if (this.connections[t].ngether.partnerConfig.poolIds.indexOf(poolIds[n]) > -1) {
					add = true;
					break;
				}
			}
		}
		if (add === true) targets.push(this.connections[t].ngether.partnerConfig.id);
	}
	return targets;
};


ngether.prototype.limitTargets = function(targets, limit) {
	while (targets.length > limit) {
		var pos = Math.floor(Math.random()*targets.length);
		targets.splice(pos,1);
	}
	return targets;
};


ngether.prototype.emit = function(topics, data, poolIds, limit) {
	// --- normalizing arguments
	if (typeof topics === 'string') topics = [ topics ];
	// collect targets
	var targets = this.getTargetConnections(poolIds);
	// we are in emit mode, where we publish to ourselves as well
	targets.push(this.id);
	// introduce limit RANDOMLY
	if (typeof limit === 'number') targets = this.limitTargets(targets, limit);
	// --- publish
	var publications = this._publishingloop('emit', topics, targets, data);
	return publications;
};


ngether.prototype.broadcast = function(topics, data, poolIds, limit) {
	// --- normalizing arguments
	if (typeof topics === 'string') topics = [ topics ];
	// collect targets
	var targets = this.getTargetConnections(poolIds);
	// introduce limit RANDOMLY
	if (typeof limit === 'number') targets = this.limitTargets(targets, limit);
	// --- publish
	var publications = this._publishingloop('broadcast', topics, targets, data);
	return publications;
};


ngether.prototype.tell = function(topics, data, targets) {
	// --- normalizing arguments
	if (typeof topics === 'string') topics = [ topics ];
	// set targets
	if (typeof targets === 'string') targets = [ targets ];
	// --- publish
	var publications = this._publishingloop('tell', topics, targets, data);
	return publications;
};


ngether.prototype.listenTo = function(topics, receiverIds, handler) {
	// ---normalizing arguments
	if (typeof receiverIds === 'function') {
		handlers = receiverIds;
		receiverIds = ['*'];
	}
	if (typeof topics === 'string') topics = [ topics ]
	if (typeof receiverIds === 'string') receiverIds = [ receiverIds ];
	else if (typeof receiverIds === 'undefined') receiverIds = [];
	// ---vars
	var subscriptions = [];
	// ---the subsription loop
	for (var n = 0; n < topics.length; n++) {
		for (var k = 0; k < receiverIds.length; k++) {
			var subId = 'listener_' + funcs.makeId(12);
			var a = receiverIds[k] + '/';
			if (receiverIds[k] === '*' || receiverIds[k] === '') {
				a = '';
			}
			var b = topics[n] + '/';
			if (topics[n] === '*' || topics[n] === '') {
				b = '';
			}
			var topic = '/fromMesh/' + a + b; 
			this.subscriptions[subId] = this.meshBubPubSub.subscribe(
				topic,
				handler,
				{ getBubbles:true },
				subId
			);
			subscriptions.push(this.subscriptions[subId]);
		}
	}
	return subscriptions;
};


ngether.prototype.initBase = function(afterInit, parameters) {
	var thisNgether = this;
	var initSteps = [];
	var step01 = {
		id: 'errorHandler',
		executor: function(next, thisEscalator) {
			process.on('uncaughtException', funcs.exceptionHandler);
			exceptionHandler = funcs.exceptionHandler;
			next();
		}
	};
	initSteps.push(step01);
	var step02 = {
		id: 'logger',
		executor: function(next, thisEscalator) {
			thisNgether.log = new classes._logger(thisNgether.config.loggingConfig, next);
		}
	};
	initSteps.push(step02);
	var step05 = {
		id: 'pid',
		delay: 5,
		executor: function(next, thisEscalator) {
			var filename = __dirname + '/ngether_' + thisNgether.config.id + '.pid';
			fs.writeFile(
				filename,
				'' + process.pid,
				function(err) {
					if (err) {
						throw err;
					}
				}
			);
			process.on(
				'exit',
				function () {
					thisNgether.log.add('removed pidfile.', 'job', 'init');
					fs.unlink(filename);
				}
			);
			thisNgether.log.add('pid: ' + process.pid, 'job', 'init');
			next();
		}
	};
	initSteps.push(step05);
	var stepListConnections = {
		id: 'stepListConnections',
		executor: function(next, thisEscalator) {
			if (thisNgether.config.listConnections === true) thisNgether.startListConnections();
			next();
		}
	};
	initSteps.push(stepListConnections);
	var stepLoadModules = {
		id: 'stepLoadModules',
		executor: function(next, thisEscalator) {
			fs.readdir(
				__dirname + '/modules',
				function(err, files) {
					for (var n=0; n < files.length; n++) {
						var toJS = files[n].indexOf('.js');
						if (toJS > -1) {
							var module = require(__dirname + '/modules/' + files[n].substr(0, toJS));
							thisNgether.modules[module.id] = module;
						}
					}
					next();
				}
			);
		}
	};
	initSteps.push(stepLoadModules);
	var step25 = {
		id: 'callback',
		executor: function(next, thisEscalator) {
			if (typeof afterInit === 'function') afterInit.apply(process, parameters);
			next();
		}
	};
	initSteps.push(step25);
	var init = new funcs.escalator('ngetherBaseInit', initSteps, false).start();
};


ngether.prototype.stopListConnections = function() {
	if (this.config.listConnectionsInterval !== 'undefined') clearInterval(this.listConnectionsInterval);
	return true;
};


ngether.prototype.startListConnections = function() {
	var thisNgether = this;
	thisNgether.stopListConnections();
	thisNgether.listConnectionsInterval = setInterval(
		function() {
			thisNgether.listConnections();
		},
		2000
	);
	thisNgether.listConnections();
	return thisNgether.listConnectionsInterval;
};


ngether.prototype.connectTo = function(target, options, callback) {
	var thisNgether = this;
	try {
		var thisSocket = new classes._engineIOclient.Socket(
			{
				host: target.host,
				port: target.port,
				transports: [ 'websocket' ]
			}
		);
	} catch(err) {
		console.log('****************************************************************************');
		exceptionHandler(err);
		return;
	}
	thisSocket.ngether = {};
	thisSocket.ngether.partnerConfig = target;
	thisSocket.ngether.direction = 'outgoing';
	thisSocket.ngether.options = (typeof options === 'object') ? options : this.config.defaultSocketOptions;
	thisSocket.on(
		'open',
		function() {
			thisNgether.connections[thisSocket.id] = thisSocket;
			thisNgether.log.add('connected to ' + target.id, 'plain', 'socketOpen');
			if (typeof callback === 'function') callback(thisSocket);
			thisSocket.on(
				'message',
				function(msg) {
					thisNgether.socketMessageHandler(thisSocket, msg);
				}
			);
			thisSocket.on(
				'close',
				function() {
					thisNgether.log.add('DISconnected', 'error', 'socketClose');
					if (thisSocket.ngether.options.autoReconnect === true) {
						thisNgether.reconnect(thisNgether.connections[thisSocket.id]);
					}
				}
			);
			var intro = {
				id: thisNgether.config.id,
				type: thisNgether.config.type,
				host: thisNgether.config.socketServer.host, 
				port: thisNgether.config.socketServer.port,
				poolIds: thisNgether.config.poolIds
			};			
			thisNgether.tell('ngether/introduceMe', intro, [ target.id ]);
		}
	);
	thisSocket.connectionOpenStart = new Date().getTime();
	thisSocket.connectionTimer = setInterval(
		function() {
			var now = new Date().getTime();
			// DEBUG
			//console.log(thisSocket.id + ' #' + thisSocket.readyState);
			if ((thisSocket.readyState === 'closed' || thisSocket.readyState === 'opening' ) && thisSocket.connectionOpenStart +2500 < now) {
				// DEBUG
				//console.log(thisSocket.id + ' ************ re-opening');
				clearInterval(thisSocket.connectionTimer);
				thisNgether.destroyConnection(thisSocket);
				thisNgether.connectTo(target, options);
			} else if (thisSocket.readyState === 'open') {
				clearInterval(thisSocket.connectionTimer);
			}
		},
		250
	);
};


ngether.prototype.modules = [];

module.exports = ngether;
console.log('[ngether] module loaded.');



