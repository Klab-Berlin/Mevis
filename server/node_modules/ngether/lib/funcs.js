var aFunctionSet = function() {};


aFunctionSet.prototype.makeId = function(length,numeric,charsonly, makeUnique) {		
	// version TW 22.10.2012 15.30
	if (typeof numeric === "undefined" || numeric !== true) numeric = false;
	if (typeof makeUnique === "undefined" || makeUnique !== true) makeUnique = false;
	var rid = "";
	if (numeric === false) {
		if (charsonly) {
			var ridchars = new Array("a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z");
		} else {
			var ridchars = new Array("1","2","3","4","5","6","7","8","9","0","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","-","_");
		}
	} else {
		var ridchars = new Array("1","2","3","4","5","6","7","8","9","0");
	}
	var acceptable = false;
	for (var i=0;i<length;i++) {
		rid += ridchars[Math.floor(Math.random()*ridchars.length)];
	}
	if (numeric === true) {
		return parseInt(rid);
	}
	return rid;
};


/* -----------------------------------------------------------------------------------------------
 * constructor: aFunctionSet.prototype.converse
 * 
 * parameters:
 *		bubPubSub - {object} give us your bubPubSub object !
 *		publication - {object}
 *			publication.topic - {string} the topic to publish
 *			publication.data - {object} anything you want the publication to send out
 *			publication.options - {object} the publish options object. defaults to {}, so your pubSub default settings will apply
 *			publication.sender - {string||object} the id or object reference you want to pass on
 *		subscription - {object}
 *			subscription.autoUnsubscribe - {false||number} defaults to 1. should your given subscription simply unsubscribe itself after being invoked once?
 *			subscription.callback - {function} what do you want to be done with your subscription 
 *			subscription.scope - {object} set the scope for your callback. if this is not set, the window(browser)/process(node)/aBubPubSubConversation(crazy) will be your scope
 *
 *		returns - {object} an instance of itself - call with new !!!
----------------------------------------------------------------------------------------------- */
aFunctionSet.prototype.aConversation = function(bubPubSub, publication, subscription) {
	return bubPubSub.converse(publication, subscription);
};


/* ----------------------------------------------------------------------------
 * ----------------------------------------------------------------------------
 *	TITLE: escalator - a flow-control class for javascript (nodeJS & browser)
 *
 *	DESCRIPTION: 
 * -  this code is part of the VisualWeb Project by 
 *	-  LinkCloud ( http://www.mylinkcloud.com )
 *	-  ViSERiON UG (haftungsbeschraenkt) ( http://www.viserion.com )  
 * -  K.Lab GmbH ( http://www.klab-berlin.com )
 * -  MIT license. 
 *
 *		in async environments - we do love them - there are times when you need to make sure foo is run after bar in all cases.
 *		for our VisualWeb framework we thus developed a object/class called escalator that allows us to write sequential code.
 *
 *	BASED ON:
 *		nothing really... it's quite different from the flow control systems i found after i had written this...
 *
 *	FILE (in VisualWeb): 
 *		/public/vw.escalator.js
 *
 * AUTHOR: 
 *		 Toni Wagner @itsatony
 * 		
 * DEPENDENCIES:
 *		- dependencies were removed ... this is totally independent now .
 *		- it should integrate into NodeJS on the server-side or any browser-side with javascript enabled.
 *
 *	TESTS: 
 *	(start code)
 *		none yet ;)
 * (end)
 *
 *	VERSION:
 *		-	v0.1.1  fixed several bugs in add and execution
 *		- v0.1.0	initial public release		08.05.2012			
 *			- removed dependencies 
 *			- enabled using the same file for client- and nodeJS server-side implementation
 *
 *	URLs:
 *		- blogpost: <http://coffeelog.itsatony.com/escalator>
 *		- github: <https://github.com/itsatony/escalator>
 *
 *	examples:
 *	
 *	#1 - three steps, different configs  
 *	(start code)
 	var someVar = 'hello';
 	var firstStep = {
		id: 'myFirstStep',
		priority: 10,
		executor: function(next, thisEscalator) {
			someVar = 'hello too'
			next();
		}
	};
	var secondStep = {
		id: 'mySecondStep',
		priority: 20,
		delay: 10,
		parameters: [ someVar ],
		scope: this,
		executor: function(somethingWePassedIn, next, thisEscalator) {
			console.log(somethingWePassedIn);
			thisEscalator.anotherVariable = 42;
			next();
		}
	};	
	var lastStep = {
		priority: 22,
		executor: function(next, thisEscalator) {
			console.log(thisEscalator.anotherVariable);
			next();
		}
	};
	var myDemoEscalator = new escalator(
		'demoEscalator',
		[ firstStep, secondStep, lastStep ]
	).start();
 * 	(end)
 *
 * ---------------------------------------------------------------------------- */ 


/* -----------------------------------------------------------------
 *	class: aEscalator 
 *		an object that runs function synchronously - one step after the next ...
 *
 *	parameters: 
 *		id - {string} the id of the escalator
 *		steps - {array} optional. if an array of step objects (format see <aEscalator.prototype.defaultStep>) is passed, they will all be added.
 *		
 *	returns: 
 * 	this - {object}
 *
 *	------------------------------------------------------------------*/
aFunctionSet.prototype.escalator = function(id, steps, debug) {
	this.id = (id) ? id : 'esc_' + Math.floor(Math.random()*1000000000);
	this.debug = (typeof debug == 'boolean') ? debug : false;
	this.steps = {};
	this.stepsLeft = [];
	this.finishedSteps = [];
	if (typeof steps === 'object' && typeof steps.length === 'number' && typeof steps.sort === 'function') {
		for (var i = 0; i < steps.length; i++) {
			this.add(steps[i]);
		}
	}
	return this;
};


/* -----------------------------------------------------------------
 *	method: aEscalator.prototype.defaultStep
 *		returns a default step object will all needed attributes
 *
 *	parameters: 
 *
 *	returns: 
 * 	aStep - {object}
 *
 *	------------------------------------------------------------------*/
aFunctionSet.prototype.escalator.prototype.defaultStep = function() {
	var aStep = {
		id: 'esc_' + Math.floor(Math.random()*1000000000), 
		priority: (this.stepsLeft.length + 1) * 10, 
		executor: function(next) { next(); return true; }, 
		parameters: [], 
		scope: (typeof process === 'object') ? process : window, 
		resetNeeded: false,
		delay: 0
	};
	return aStep;
};


/* -----------------------------------------------------------------
 *	method: aEscalator.prototype.add
 *		an object that runs function synchronously - one step after the next ...
 *
 *	parameters: 
 *		id - {string || object} - if this is an object, all the step parameters need to be attributes. see <aEscalator.prototype.defaultStep>. additional arguments will be ignored.
 *		priority - {number}
 *		executor - {function}
 *		parameters - {array} executor will receive these arguments
 *		scope - {object} executor will get this scope applied. defaults to this
 *		delay - {number} ms to wait before taking the next step
 *
 *	returns: 
 * 	this - {object}
 *
 *	------------------------------------------------------------------*/
aFunctionSet.prototype.escalator.prototype.add = function(id, priority, executor, parameters, scope, resetNeeded, delay) {
	var thisEscalator = this;
	var defaultStep = this.defaultStep();
	if (typeof arguments[0] === 'object' && typeof arguments[0].executor === 'function') {
		var thisStep = arguments[0];
		var id = thisStep.id;
	} else {
		var thisStep = {
			id: id,
			priority: priority,
			executor: executor,
			parameters: parameters,
			scope: scope,
			resetNeeded: resetNeeded,
			delay: delay
		};
	}
	var newStep = {};
	for (var i in defaultStep) newStep[i] = defaultStep[i];
	for (var i in thisStep) newStep[i] = thisStep[i];
	
	if (typeof newStep.executor !== 'function') {
		if (this.debug === true) {
			console.log('[escalator] no executor function! ');
			console.log(newStep);
		}
		return false;
	}
	if (typeof newStep.priority !== 'number') newStep.priority = (this.stepsLeft.length + 1) * 10;
	if (typeof newStep.parameters !== 'object' || typeof newStep.parameters.length !== 'number') newStep.parameters = [];
	if (typeof newStep.scope !== 'object') newStep.scope = (typeof process === 'object') ? process : window;
	newStep.parameters.push(function() {
		thisEscalator.next();
	});
	newStep.parameters.push(thisEscalator);
	if (this.debug === true) console.log('[escalator] {' + this.id + '} step added: ' + newStep.id);
	this.steps[newStep.id] = newStep;
	if (newStep.resetNeeded) this.reset();
	else this.update(this.steps[id]);
	if (this.finishedSteps.length > 0) {
		// if (this.debug === true) console.log(this.steps[id]);
	}
	return this;
};


/* -----------------------------------------------------------------
 *	method: aEscalator.prototype.reset
 *		reset this escalator - all steps are sorted by prio and added to a (pre-emptied) this.stepsLeft array
 *
 *	parameters: 
 *
 *	returns: 
 * 	this - {object}
 *
 *	------------------------------------------------------------------*/
aFunctionSet.prototype.escalator.prototype.reset = function() {
	this.stepsLeft = [];
	this.finishedSteps = [];
	for (var i in this.steps) {
		this.stepsLeft.push(this.steps[i]);
	}
	this.stepsLeft.sort(this.sorter);
	return this;
};


/* -----------------------------------------------------------------
 *	method: aEscalator.prototype.reset
 *		reset this escalator - all steps are sorted by prio and added to a (pre-emptied) this.stepsLeft array
 *
 *	parameters: 
 *
 *	returns: 
 * 	this - {object}
 *
 *	------------------------------------------------------------------*/
aFunctionSet.prototype.escalator.prototype.update = function(newStep) {
	this.stepsLeft.push(newStep);
	this.stepsLeft.sort(this.sorter);
	return this;
};


/* -----------------------------------------------------------------
 *	method: aEscalator.prototype.remove
 *		remove a step - this will auto-trigger a reset: <aEscalator.prototype.reset>
 *
 *	parameters: 
 *		id - {string}
 *
 *	returns: 
 * 	this - {object}
 *
 *	------------------------------------------------------------------*/
aFunctionSet.prototype.escalator.prototype.remove = function(id) {
	delete this.steps[id];
	this.reset();
	return this;
};


/* -----------------------------------------------------------------
 *	method: aEscalator.prototype.finish
 *		triggers a finished event!
 *
 *	parameters: 
 *		id - {string}
 *
 *	returns: 
 * 	this - {object}
 *
 *	------------------------------------------------------------------*/
aFunctionSet.prototype.escalator.prototype.finish = function(err) {
	if (typeof err !== 'undefined') {
		if (this.debug === true) console.log('[escalator] {' + this.id + '} triggered FINISHED WITH ERROR!!!');
		this.error = err;
	} else {
		if (this.debug === true) console.log('[escalator] {' + this.id + '} triggered FINISHED!');
	}
	if (typeof this.onFinish === 'function') this.onFinish(this);
	return this;
};


/* -----------------------------------------------------------------
 *	method: aEscalator.prototype.start
 *		triggers a succession of <aEscalator.prototype.reset> and <aEscalator.prototype.next>
 *
 *	parameters: 
 *
 *	returns: 
 * 	this - {object}
 *
 *	------------------------------------------------------------------*/
aFunctionSet.prototype.escalator.prototype.start = function() {
	if (this.debug == true) console.log('[escalator] {' + this.id + '} triggered START!');
	this.reset();
	this.next();
	return this;
};


/* -----------------------------------------------------------------
 *	method: aEscalator.prototype.next
 *		move to the next step
 *
 *	parameters: 
 *
 *	returns: 
 * 	this - {object}
 *
 *	------------------------------------------------------------------*/
aFunctionSet.prototype.escalator.prototype.next = function() {
	var thisEscalator = this;
	if (typeof thisEscalator.id !== 'string' || typeof thisEscalator.finish !== 'function') return false;
	if (typeof this.stepsLeft !== 'object' || typeof this.stepsLeft.length !== 'number') return this;
	if (this.stepsLeft.length < 1) {
		return this.finish();
	}
	var thisStep = this.stepsLeft.shift();
	if (typeof thisStep !== 'object' || typeof thisStep.parameters !== 'object') {
		if (this.debug === true) {
			console.log('[escalator] {' + thisEscalator.id + '} failed step: ');
			console.log(thisStep);
		}
		thisEscalator.next();
		return;
	}
	var myParameters = [];
	for (var i in arguments) { myParameters.push(arguments[i]); };
	if (typeof thisStep.parameters !== 'object' || typeof thisStep.parameters.length !== 'number') {
		thisStep.parameters = [];
		thisStep.parameters.push(function() {
			thisEscalator.next();
		});
		thisStep.parameters.push(thisEscalator);
	}
	for (var i in thisStep.parameters) { 
		myParameters.push(thisStep.parameters[i]); 
	};
	if (this.debug === true) console.log('[escalator] {' + this.id + '} triggered NEXT step: (' + thisStep.id + ')');
	try {
		if (thisStep.delay > 0) {
			thisStep.timeout = setTimeout(
				function() { thisStep.executor.apply(thisStep.scope, myParameters); },
				thisStep.delay
			);
		} else {
				thisStep.executor.apply(thisStep.scope, myParameters);
		}
		thisEscalator.finishedSteps.push(thisStep);
	} catch(err) {
		console.log('[escalator] {' + this.id + '} triggered ERROR during step: (' + thisStep.id + ')');
		throw err;
	}
	return this;
};


/* -----------------------------------------------------------------
 *	method: aEscalator.prototype.sorter
 *		this is a sorting function used for this.stepsLeft array of objects.
 *
 *	parameters: 
 *		a - {object}
 *		b - {object}
 *
 *	returns: 
 * 	a.priority - b.priority - {number}
 *
 *	------------------------------------------------------------------*/
aFunctionSet.prototype.escalator.prototype.sorter = function(a,b) {
	return a.priority - b.priority;
};


aFunctionSet.prototype.exceptionHandler = function (err, data) {
	console.log(arguments);
	var me = arguments;
	var myCallee = arguments.callee;
	var myCaller = arguments.caller;
	if (typeof data == 'undefined') data = '[none]';
	console.log('[SYSTEMIC ERROR]');
	console.log(err);
	if (typeof errors === 'undefined') errors = [];
	errors.push(err);
	if (errors.length > 100) errors.shift();
	if (typeof err.stack !== 'undefined') {
		console.log(err.stack);		
	}
	return true;
};


/* -----------------------------------------------------------------
 *	function: aFunctionSet.prototype.openSocktREPL
 *		opens a TCP socket for connecting to the code console
 *
 *	parameters: 
 *		port - {number} the port on which to listen
 *
 *	returns: 
 * 		TCPServer - {object} the server object
 *
 *	------------------------------------------------------------------*/
aFunctionSet.prototype.openSocktREPL = function(serverId, port) {
	var net = require('net');
	var repl = require('repl');
	if (typeof port !== 'number') return null;
	var TCPServer = net.createServer(
		function (socket) {
			repl.start(
				{
					prompt: '[' + serverId + '] > ',
					input: socket,
					output: socket,
					terminal: true
				}
			)
			.on(
				'exit', 
				function() {
					socket.end();
				}
			);
		}
	).listen(port);
	console.log('[REPL] listening on port ' + port);
	return TCPServer;
};


console.log('[funcs] module loaded.');
module.exports = aFunctionSet;